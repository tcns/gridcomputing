/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddOrderRequest
 */
export interface AddOrderRequest {
    /**
     * 
     * @type {boolean}
     * @memberof AddOrderRequest
     */
    'randomizeTokenAmount': boolean;
    /**
     * 
     * @type {number}
     * @memberof AddOrderRequest
     */
    'fixedAmountPercent'?: number;
}
/**
 * 
 * @export
 * @interface AddOrderResponse
 */
export interface AddOrderResponse {
    /**
     * 
     * @type {OrderDto}
     * @memberof AddOrderResponse
     */
    'order': OrderDto;
}
/**
 * 
 * @export
 * @interface AdditionalMetadataDto
 */
export interface AdditionalMetadataDto {
    /**
     * 
     * @type {string}
     * @memberof AdditionalMetadataDto
     */
    'banner': string;
    /**
     * 
     * @type {string}
     * @memberof AdditionalMetadataDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'iv'?: string;
}
/**
 * 
 * @export
 * @interface AuctionOrder
 */
export interface AuctionOrder {
    /**
     * 
     * @type {OrderSignData}
     * @memberof AuctionOrder
     */
    'signData': OrderSignData;
    /**
     * 
     * @type {BribeSignData}
     * @memberof AuctionOrder
     */
    'bribeSignData'?: BribeSignData;
    /**
     * 
     * @type {AddOrderResponse}
     * @memberof AuctionOrder
     */
    'orderResponse': AddOrderResponse;
}
/**
 * 
 * @export
 * @interface AuctionStateRequest
 */
export interface AuctionStateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof AuctionStateRequest
     */
    'auctionOpen': boolean;
}
/**
 * 
 * @export
 * @interface AuctionStatsResponse
 */
export interface AuctionStatsResponse {
    /**
     * 
     * @type {number}
     * @memberof AuctionStatsResponse
     */
    'totalBribe': number;
    /**
     * 
     * @type {number}
     * @memberof AuctionStatsResponse
     */
    'effectiveBribe': number;
    /**
     * 
     * @type {number}
     * @memberof AuctionStatsResponse
     */
    'minBribe': number;
    /**
     * 
     * @type {number}
     * @memberof AuctionStatsResponse
     */
    'totalOrders': number;
    /**
     * 
     * @type {number}
     * @memberof AuctionStatsResponse
     */
    'validOrders': number;
    /**
     * 
     * @type {number}
     * @memberof AuctionStatsResponse
     */
    'spots': number;
}
/**
 * 
 * @export
 * @interface BribeSignData
 */
export interface BribeSignData {
    /**
     * 
     * @type {string}
     * @memberof BribeSignData
     */
    'to'?: string;
    /**
     * 
     * @type {number}
     * @memberof BribeSignData
     */
    'ethAmount': number;
    /**
     * 
     * @type {string}
     * @memberof BribeSignData
     */
    'transactionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BribeSignData
     */
    'signed': boolean;
    /**
     * 
     * @type {string}
     * @memberof BribeSignData
     */
    'signer'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BribeSignData
     */
    'inclulded': boolean;
}
/**
 * Присутствует только в случае status <> \'SUCCESS\'
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'blockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface BundleSubmissionData
 */
export interface BundleSubmissionData {
    /**
     * 
     * @type {boolean}
     * @memberof BundleSubmissionData
     */
    'success': boolean;
    /**
     * 
     * @type {number}
     * @memberof BundleSubmissionData
     */
    'blockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof BundleSubmissionData
     */
    'launchTxHash': string;
}
/**
 * 
 * @export
 * @interface BundleSubmissionError
 */
export interface BundleSubmissionError extends CoinLaunchError {
    /**
     * 
     * @type {string}
     * @memberof BundleSubmissionError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface BundleTypeUpdateRequest
 */
export interface BundleTypeUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof BundleTypeUpdateRequest
     */
    'bundleType': BundleTypeUpdateRequestBundleTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BundleTypeUpdateRequest
     */
    'auctionSpots': number;
    /**
     * 
     * @type {number}
     * @memberof BundleTypeUpdateRequest
     */
    'auctionMaxTx'?: number;
}

export const BundleTypeUpdateRequestBundleTypeEnum = {
    Regular: 'Regular',
    Auction: 'Auction',
    Lottery: 'Lottery'
} as const;

export type BundleTypeUpdateRequestBundleTypeEnum = typeof BundleTypeUpdateRequestBundleTypeEnum[keyof typeof BundleTypeUpdateRequestBundleTypeEnum];

/**
 * 
 * @export
 * @interface BuySellTax
 */
export interface BuySellTax {
    /**
     * 
     * @type {number}
     * @memberof BuySellTax
     */
    'buyTax': number;
    /**
     * 
     * @type {number}
     * @memberof BuySellTax
     */
    'sellTax': number;
}
/**
 * 
 * @export
 * @interface ByLiquidity
 */
export interface ByLiquidity extends LaunchDataUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof ByLiquidity
     */
    'tokens': number;
    /**
     * 
     * @type {number}
     * @memberof ByLiquidity
     */
    'ethers': number;
}


/**
 * 
 * @export
 * @interface ByMethod
 */
export interface ByMethod extends LaunchDataUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof ByMethod
     */
    'methodId': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ByMethod
     */
    'args': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ByMethod
     */
    'tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof ByMethod
     */
    'ethers'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ByMethod
     */
    'liqOnMethod': boolean;
}


/**
 * 
 * @export
 * @interface CexBalanceResponse
 */
export interface CexBalanceResponse {
    /**
     * 
     * @type {string}
     * @memberof CexBalanceResponse
     */
    'cexType': CexBalanceResponseCexTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CexBalanceResponse
     */
    'balance': number;
}

export const CexBalanceResponseCexTypeEnum = {
    Mexc: 'MEXC'
} as const;

export type CexBalanceResponseCexTypeEnum = typeof CexBalanceResponseCexTypeEnum[keyof typeof CexBalanceResponseCexTypeEnum];

/**
 * 
 * @export
 * @interface CexSettings
 */
export interface CexSettings {
    /**
     * 
     * @type {boolean}
     * @memberof CexSettings
     */
    'verified': boolean;
    /**
     * 
     * @type {ApiKey}
     * @memberof CexSettings
     */
    'apiKey': ApiKey;
    /**
     * 
     * @type {string}
     * @memberof CexSettings
     */
    'fundingAddress'?: string;
}
/**
 * 
 * @export
 * @interface CheckVerificationResponse
 */
export interface CheckVerificationResponse {
    /**
     * 
     * @type {CoinDto}
     * @memberof CheckVerificationResponse
     */
    'coin': CoinDto;
}
/**
 * 
 * @export
 * @interface CheckerRequest
 */
export interface CheckerRequest {
    /**
     * 
     * @type {string}
     * @memberof CheckerRequest
     */
    'tokenUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckerRequest
     */
    'dataUrl'?: string;
}
/**
 * 
 * @export
 * @interface CheckerResponse
 */
export interface CheckerResponse {
    /**
     * 
     * @type {string}
     * @memberof CheckerResponse
     */
    'status': CheckerResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckerResponse
     */
    'generalErrorMessage'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckerResponse
     */
    'detailedMessages': Array<string>;
}

export const CheckerResponseStatusEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type CheckerResponseStatusEnum = typeof CheckerResponseStatusEnum[keyof typeof CheckerResponseStatusEnum];

/**
 * 
 * @export
 * @interface CoinDto
 */
export interface CoinDto {
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'contractAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'chainId': number;
    /**
     * 
     * @type {Array<MethodDto>}
     * @memberof CoinDto
     */
    'methods': Array<MethodDto>;
    /**
     * 
     * @type {UpdateLaunchType200Response}
     * @memberof CoinDto
     */
    'launchParams'?: UpdateLaunchType200Response;
    /**
     * 
     * @type {boolean}
     * @memberof CoinDto
     */
    'paid': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinDto
     */
    'liquidityAdded': boolean;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'maxTxInPercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'buySupplyInPercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'buyTax'?: number;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'sellTax'?: number;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'totalSupply'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'paymentWallet': string;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'pairContractAddress'?: string;
    /**
     * 
     * @type {Lock}
     * @memberof CoinDto
     */
    'lock'?: Lock;
    /**
     * 
     * @type {boolean}
     * @memberof CoinDto
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'abi'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'state': CoinDtoStateEnum;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'requiredPayAmount': number;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'coinType': CoinDtoCoinTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'wizardStep': number;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'decimals'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'poolType': CoinDtoPoolTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'ethInPool': number;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'tokenInPool': number;
    /**
     * 
     * @type {GeneratorParams}
     * @memberof CoinDto
     */
    'generatorParams'?: GeneratorParams;
    /**
     * 
     * @type {DeployedTokenData}
     * @memberof CoinDto
     */
    'deployedTokenData'?: DeployedTokenData;
    /**
     * 
     * @type {BundleSubmissionData}
     * @memberof CoinDto
     */
    'bundleSubmissionData'?: BundleSubmissionData;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'auctionSpots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CoinDto
     */
    'auctionOpen': boolean;
    /**
     * 
     * @type {number}
     * @memberof CoinDto
     */
    'auctionMaxTx'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoinDto
     */
    'bundleType': CoinDtoBundleTypeEnum;
}

export const CoinDtoStateEnum = {
    Draft: 'DRAFT',
    Deployed: 'DEPLOYED',
    Launching: 'LAUNCHING',
    Launched: 'LAUNCHED'
} as const;

export type CoinDtoStateEnum = typeof CoinDtoStateEnum[keyof typeof CoinDtoStateEnum];
export const CoinDtoCoinTypeEnum = {
    Generated: 'Generated',
    Lbp: 'LBP',
    Hardfork: 'Hardfork',
    Imported: 'Imported',
    FromFile: 'FromFile'
} as const;

export type CoinDtoCoinTypeEnum = typeof CoinDtoCoinTypeEnum[keyof typeof CoinDtoCoinTypeEnum];
export const CoinDtoPoolTypeEnum = {
    UniswapV2: 'UNISWAP_V2',
    Vista: 'VISTA',
    UniswapV3: 'UNISWAP_V3'
} as const;

export type CoinDtoPoolTypeEnum = typeof CoinDtoPoolTypeEnum[keyof typeof CoinDtoPoolTypeEnum];
export const CoinDtoBundleTypeEnum = {
    Regular: 'Regular',
    Auction: 'Auction',
    Lottery: 'Lottery'
} as const;

export type CoinDtoBundleTypeEnum = typeof CoinDtoBundleTypeEnum[keyof typeof CoinDtoBundleTypeEnum];

/**
 * 
 * @export
 * @interface CoinFeatures
 */
export interface CoinFeatures {
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'blacklist': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'antiWhale': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'safeDevActions': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'liquidityOnEnableTrading': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'burnFeeEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'antiSniperEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'marketingFeeEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'liquidityFeeEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'reflectionFeeEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'blacklistRenounce': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'feesExcludeEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'changePairEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'lpBurnEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'transferDelayEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CoinFeatures
     */
    'lockOnLaunch': boolean;
}
/**
 * 
 * @export
 * @interface CoinLaunchError
 */
export interface CoinLaunchError {
    /**
     * 
     * @type {string}
     * @memberof CoinLaunchError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface CoinLaunchResponse
 */
export interface CoinLaunchResponse {
    /**
     * 
     * @type {string}
     * @memberof CoinLaunchResponse
     */
    'status': CoinLaunchResponseStatusEnum;
    /**
     * 
     * @type {CoinDto}
     * @memberof CoinLaunchResponse
     */
    'coin': CoinDto;
    /**
     * 
     * @type {Bundle}
     * @memberof CoinLaunchResponse
     */
    'bundle'?: Bundle;
    /**
     * 
     * @type {Array<CoinLaunchResponseErrorsInner>}
     * @memberof CoinLaunchResponse
     */
    'errors': Array<CoinLaunchResponseErrorsInner>;
}

export const CoinLaunchResponseStatusEnum = {
    Success: 'SUCCESS',
    ValidationError: 'VALIDATION_ERROR',
    BundleSubmissionError: 'BUNDLE_SUBMISSION_ERROR'
} as const;

export type CoinLaunchResponseStatusEnum = typeof CoinLaunchResponseStatusEnum[keyof typeof CoinLaunchResponseStatusEnum];

/**
 * @type CoinLaunchResponseErrorsInner
 * @export
 */
export type CoinLaunchResponseErrorsInner = BundleSubmissionError | LaunchTransactionMissed | OrderSameFrom | OrderWithoutTx | OrdersIsEmpty | ServiceUnpaid | TransactionInvalid | TransactionUnsigned;

/**
 * 
 * @export
 * @interface CoinParams
 */
export interface CoinParams {
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'caName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'totalSupply': number;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'caComment': string;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'maxWalletPercent': number;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'maxTxPercent': number;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'minTxPercent': number;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'maxTxReduced': number;
    /**
     * 
     * @type {BuySellTax}
     * @memberof CoinParams
     */
    'liqFeePercent': BuySellTax;
    /**
     * 
     * @type {BuySellTax}
     * @memberof CoinParams
     */
    'marketingFeePercent': BuySellTax;
    /**
     * 
     * @type {BuySellTax}
     * @memberof CoinParams
     */
    'reflectFeePercent': BuySellTax;
    /**
     * 
     * @type {BuySellTax}
     * @memberof CoinParams
     */
    'burnFeePercent': BuySellTax;
    /**
     * 
     * @type {BuySellTax}
     * @memberof CoinParams
     */
    'taxRestrictions': BuySellTax;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'marketingAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'cloggPercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'initialLiquidity'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'lockType': CoinParamsLockTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'lockDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'dataUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'tokenUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'nftDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'externalUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'defaultTraitName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CoinParams
     */
    'defaultTraitValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'totalBuyFee': number;
    /**
     * 
     * @type {number}
     * @memberof CoinParams
     */
    'totalSellFee': number;
}

export const CoinParamsLockTypeEnum = {
    None: 'None',
    Burn: 'Burn',
    Lock: 'Lock'
} as const;

export type CoinParamsLockTypeEnum = typeof CoinParamsLockTypeEnum[keyof typeof CoinParamsLockTypeEnum];

/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'wallet': string;
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'contractAddress': string;
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface CreateCoinParams
 */
export interface CreateCoinParams {
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'coinType': CreateCoinParamsCoinTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'poolType': CreateCoinParamsPoolTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'caName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'deployerAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCoinParams
     */
    'totalSupply': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCoinParams
     */
    'ethAmount': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCoinParams
     */
    'cloggPercent': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCoinParams
     */
    'liquidityOnEnableTrading': boolean;
    /**
     * 
     * @type {BuySellTax}
     * @memberof CreateCoinParams
     */
    'marketingFee': BuySellTax;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'ownerWallet'?: string;
    /**
     * 
     * @type {LockParams}
     * @memberof CreateCoinParams
     */
    'lockParams': LockParams;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinParams
     */
    'caSourceType': CreateCoinParamsCaSourceTypeEnum;
}

export const CreateCoinParamsCoinTypeEnum = {
    Generated: 'Generated',
    Lbp: 'LBP',
    Hardfork: 'Hardfork',
    Imported: 'Imported',
    FromFile: 'FromFile'
} as const;

export type CreateCoinParamsCoinTypeEnum = typeof CreateCoinParamsCoinTypeEnum[keyof typeof CreateCoinParamsCoinTypeEnum];
export const CreateCoinParamsPoolTypeEnum = {
    UniswapV2: 'UNISWAP_V2',
    Vista: 'VISTA',
    UniswapV3: 'UNISWAP_V3'
} as const;

export type CreateCoinParamsPoolTypeEnum = typeof CreateCoinParamsPoolTypeEnum[keyof typeof CreateCoinParamsPoolTypeEnum];
export const CreateCoinParamsCaSourceTypeEnum = {
    Standard: 'Standard',
    Reflection: 'Reflection',
    Erc404: 'ERC404',
    Instant: 'Instant'
} as const;

export type CreateCoinParamsCaSourceTypeEnum = typeof CreateCoinParamsCaSourceTypeEnum[keyof typeof CreateCoinParamsCaSourceTypeEnum];

/**
 * 
 * @export
 * @interface CreateCoinRequest
 */
export interface CreateCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    'contractAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    'type': CreateCoinRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    'poolType': CreateCoinRequestPoolTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    'abi'?: string;
    /**
     * 
     * @type {CreateCoinParams}
     * @memberof CreateCoinRequest
     */
    'createCoinParams'?: CreateCoinParams;
}

export const CreateCoinRequestTypeEnum = {
    Generated: 'Generated',
    Lbp: 'LBP',
    Hardfork: 'Hardfork',
    Imported: 'Imported',
    FromFile: 'FromFile'
} as const;

export type CreateCoinRequestTypeEnum = typeof CreateCoinRequestTypeEnum[keyof typeof CreateCoinRequestTypeEnum];
export const CreateCoinRequestPoolTypeEnum = {
    UniswapV2: 'UNISWAP_V2',
    Vista: 'VISTA',
    UniswapV3: 'UNISWAP_V3'
} as const;

export type CreateCoinRequestPoolTypeEnum = typeof CreateCoinRequestPoolTypeEnum[keyof typeof CreateCoinRequestPoolTypeEnum];

/**
 * 
 * @export
 * @interface CreateCommentRequest
 */
export interface CreateCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequest
     */
    'contractAddress': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequest
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    'from': string;
}
/**
 * 
 * @export
 * @interface CreateTransactionResponse
 */
export interface CreateTransactionResponse {
    /**
     * 
     * @type {TransactionDto}
     * @memberof CreateTransactionResponse
     */
    'transaction': TransactionDto;
}
/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * 
     * @type {number}
     * @memberof Dashboard
     */
    'unrealizedBalance': number;
    /**
     * 
     * @type {number}
     * @memberof Dashboard
     */
    'todayEarnings': number;
    /**
     * 
     * @type {number}
     * @memberof Dashboard
     */
    'todayTasks': number;
    /**
     * 
     * @type {number}
     * @memberof Dashboard
     */
    'totalEarnings': number;
    /**
     * 
     * @type {number}
     * @memberof Dashboard
     */
    'totalTasks': number;
    /**
     * 
     * @type {Node}
     * @memberof Dashboard
     */
    'connectedNode'?: Node;
    /**
     * 
     * @type {Array<EarningStat>}
     * @memberof Dashboard
     */
    'earningsToday': Array<EarningStat>;
    /**
     * 
     * @type {Array<EarningStat>}
     * @memberof Dashboard
     */
    'earning15Days': Array<EarningStat>;
    /**
     * 
     * @type {DataProcessedCumulative}
     * @memberof Dashboard
     */
    'dataProcessedCumulative': DataProcessedCumulative;
    /**
     * 
     * @type {Array<EarningStat>}
     * @memberof Dashboard
     */
    'earning30Days': Array<EarningStat>;
    /**
     * 
     * @type {Array<Node>}
     * @memberof Dashboard
     */
    'nodes': Array<Node>;
}
/**
 * 
 * @export
 * @interface DataProcessedCumulative
 */
export interface DataProcessedCumulative {
    /**
     * 
     * @type {number}
     * @memberof DataProcessedCumulative
     */
    'totalTasks': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DataProcessedCumulative
     */
    'last15Days': Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteLaunchTransactionResponse
 */
export interface DeleteLaunchTransactionResponse {
    /**
     * 
     * @type {CoinDto}
     * @memberof DeleteLaunchTransactionResponse
     */
    'coin': CoinDto;
}
/**
 * 
 * @export
 * @interface DeployCoinRequest
 */
export interface DeployCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof DeployCoinRequest
     */
    'coinAddress': string;
}
/**
 * 
 * @export
 * @interface DeployedTokenData
 */
export interface DeployedTokenData {
    /**
     * 
     * @type {string}
     * @memberof DeployedTokenData
     */
    'sourceCode': string;
    /**
     * 
     * @type {string}
     * @memberof DeployedTokenData
     */
    'byteCode': string;
    /**
     * 
     * @type {string}
     * @memberof DeployedTokenData
     */
    'abi': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployedTokenData
     */
    'constructorParams': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeployedTokenData
     */
    'constructorCompiled'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeployedTokenData
     */
    'compilerVersion'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeployedTokenData
     */
    'optimizationUsed': boolean;
    /**
     * 
     * @type {number}
     * @memberof DeployedTokenData
     */
    'runs': number;
    /**
     * 
     * @type {string}
     * @memberof DeployedTokenData
     */
    'deployedByteCode'?: string;
}
/**
 * 
 * @export
 * @interface EarningStat
 */
export interface EarningStat {
    /**
     * 
     * @type {string}
     * @memberof EarningStat
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof EarningStat
     */
    'earnings': number;
    /**
     * 
     * @type {number}
     * @memberof EarningStat
     */
    'bytes': number;
    /**
     * 
     * @type {number}
     * @memberof EarningStat
     */
    'share': number;
}
/**
 * 
 * @export
 * @interface GenerateCoin1Request
 */
export interface GenerateCoin1Request {
    /**
     * 
     * @type {File}
     * @memberof GenerateCoin1Request
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface GeneratorParams
 */
export interface GeneratorParams {
    /**
     * 
     * @type {CoinFeatures}
     * @memberof GeneratorParams
     */
    'coinFeatures': CoinFeatures;
    /**
     * 
     * @type {CoinParams}
     * @memberof GeneratorParams
     */
    'coinParams': CoinParams;
    /**
     * 
     * @type {string}
     * @memberof GeneratorParams
     */
    'contractType': GeneratorParamsContractTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GeneratorParams
     */
    'wizardType'?: GeneratorParamsWizardTypeEnum;
    /**
     * 
     * @type {MethodNames}
     * @memberof GeneratorParams
     */
    'methodNames': MethodNames;
    /**
     * 
     * @type {string}
     * @memberof GeneratorParams
     */
    'sourceType': GeneratorParamsSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GeneratorParams
     */
    'deployerAddress'?: string;
}

export const GeneratorParamsContractTypeEnum = {
    Simple: 'Simple',
    Standard: 'Standard',
    Reflection: 'Reflection',
    Burn: 'Burn',
    Custom: 'Custom'
} as const;

export type GeneratorParamsContractTypeEnum = typeof GeneratorParamsContractTypeEnum[keyof typeof GeneratorParamsContractTypeEnum];
export const GeneratorParamsWizardTypeEnum = {
    Newbie: 'Newbie',
    Advanced: 'Advanced',
    Erc404: 'ERC404'
} as const;

export type GeneratorParamsWizardTypeEnum = typeof GeneratorParamsWizardTypeEnum[keyof typeof GeneratorParamsWizardTypeEnum];
export const GeneratorParamsSourceTypeEnum = {
    Standard: 'Standard',
    Reflection: 'Reflection',
    Erc404: 'ERC404',
    Instant: 'Instant'
} as const;

export type GeneratorParamsSourceTypeEnum = typeof GeneratorParamsSourceTypeEnum[keyof typeof GeneratorParamsSourceTypeEnum];

/**
 * 
 * @export
 * @interface GetCoinBasicResponse
 */
export interface GetCoinBasicResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCoinBasicResponse
     */
    'coinAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetCoinBasicResponse
     */
    'pairAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetCoinBasicResponse
     */
    'coinName': string;
    /**
     * 
     * @type {string}
     * @memberof GetCoinBasicResponse
     */
    'coinSymbol': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetCoinBasicResponse
     */
    'launched': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetCoinBasicResponse
     */
    'auctionOpen': boolean;
}
/**
 * 
 * @export
 * @interface GetCoinLBPResponse
 */
export interface GetCoinLBPResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'coinAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'pairAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'coinName': string;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'coinSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'totalSupply': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetCoinLBPResponse
     */
    'listed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'state'?: GetCoinLBPResponseStateEnum;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'ethersToRise'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'ethRaised'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'ownerWallet'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'currentPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'imgUri'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'currentPriceUsd': number;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'tokensToBuy': number;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'percentToBuy': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetCoinLBPResponse
     */
    'socials': { [key: string]: string; };
    /**
     * 
     * @type {Array<LBPTransactionDto>}
     * @memberof GetCoinLBPResponse
     */
    'transactions': Array<LBPTransactionDto>;
    /**
     * 
     * @type {Array<HolderDto>}
     * @memberof GetCoinLBPResponse
     */
    'holders': Array<HolderDto>;
    /**
     * 
     * @type {Array<CommentDto>}
     * @memberof GetCoinLBPResponse
     */
    'comments': Array<CommentDto>;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'curveTotalSupply'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'lock': GetCoinLBPResponseLockEnum;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'unlockTimestamp'?: string;
    /**
     * 
     * @type {LBPFeatures}
     * @memberof GetCoinLBPResponse
     */
    'features'?: LBPFeatures;
    /**
     * 
     * @type {AdditionalMetadataDto}
     * @memberof GetCoinLBPResponse
     */
    'additionalMetadata'?: AdditionalMetadataDto;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'volumeEth': number;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'volumeUsd': number;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'marketCapUsd': number;
    /**
     * 
     * @type {number}
     * @memberof GetCoinLBPResponse
     */
    'liquidityUsd': number;
    /**
     * 
     * @type {string}
     * @memberof GetCoinLBPResponse
     */
    'poolType': GetCoinLBPResponsePoolTypeEnum;
}

export const GetCoinLBPResponseStateEnum = {
    Rising: 'RISING',
    Rised: 'RISED',
    Live: 'LIVE'
} as const;

export type GetCoinLBPResponseStateEnum = typeof GetCoinLBPResponseStateEnum[keyof typeof GetCoinLBPResponseStateEnum];
export const GetCoinLBPResponseLockEnum = {
    None: 'None',
    Burn: 'Burn',
    Lock: 'Lock'
} as const;

export type GetCoinLBPResponseLockEnum = typeof GetCoinLBPResponseLockEnum[keyof typeof GetCoinLBPResponseLockEnum];
export const GetCoinLBPResponsePoolTypeEnum = {
    UniswapV2: 'UNISWAP_V2',
    Vista: 'VISTA',
    UniswapV3: 'UNISWAP_V3'
} as const;

export type GetCoinLBPResponsePoolTypeEnum = typeof GetCoinLBPResponsePoolTypeEnum[keyof typeof GetCoinLBPResponsePoolTypeEnum];

/**
 * 
 * @export
 * @interface GetCoinResponse
 */
export interface GetCoinResponse {
    /**
     * 
     * @type {CoinDto}
     * @memberof GetCoinResponse
     */
    'coin': CoinDto;
}
/**
 * 
 * @export
 * @interface GetLastBuysResponse
 */
export interface GetLastBuysResponse {
    /**
     * 
     * @type {Array<LastBuyDto>}
     * @memberof GetLastBuysResponse
     */
    'buys': Array<LastBuyDto>;
}
/**
 * 
 * @export
 * @interface GetLaunchMethodTransactionResponse
 */
export interface GetLaunchMethodTransactionResponse {
    /**
     * 
     * @type {TransactionDto}
     * @memberof GetLaunchMethodTransactionResponse
     */
    'transaction'?: TransactionDto;
}
/**
 * 
 * @export
 * @interface GetOrdersResponse
 */
export interface GetOrdersResponse {
    /**
     * 
     * @type {Array<OrderDto>}
     * @memberof GetOrdersResponse
     */
    'orders': Array<OrderDto>;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersResponse
     */
    'totalOrders': number;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersResponse
     */
    'totalSnipePercent': number;
}
/**
 * 
 * @export
 * @interface GetSignDataResponse
 */
export interface GetSignDataResponse {
    /**
     * 
     * @type {GetSignDataResponseData}
     * @memberof GetSignDataResponse
     */
    'data': GetSignDataResponseData;
}
/**
 * @type GetSignDataResponseData
 * @export
 */
export type GetSignDataResponseData = LaunchSignData | OrderSignData;

/**
 * 
 * @export
 * @interface GetTransactionResponse
 */
export interface GetTransactionResponse {
    /**
     * 
     * @type {TransactionDto}
     * @memberof GetTransactionResponse
     */
    'transaction'?: TransactionDto;
}
/**
 * 
 * @export
 * @interface HolderDto
 */
export interface HolderDto {
    /**
     * 
     * @type {string}
     * @memberof HolderDto
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof HolderDto
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof HolderDto
     */
    'percent': number;
    /**
     * 
     * @type {string}
     * @memberof HolderDto
     */
    'type': HolderDtoTypeEnum;
}

export const HolderDtoTypeEnum = {
    Dev: 'DEV',
    User: 'USER',
    Pool: 'POOL'
} as const;

export type HolderDtoTypeEnum = typeof HolderDtoTypeEnum[keyof typeof HolderDtoTypeEnum];

/**
 * 
 * @export
 * @interface LBPFeatures
 */
export interface LBPFeatures {
    /**
     * 
     * @type {number}
     * @memberof LBPFeatures
     */
    'buyMarketingFee': number;
    /**
     * 
     * @type {number}
     * @memberof LBPFeatures
     */
    'sellMarketingFee': number;
    /**
     * 
     * @type {string}
     * @memberof LBPFeatures
     */
    'marketingWallet': string;
    /**
     * 
     * @type {number}
     * @memberof LBPFeatures
     */
    'maxTxPercent': number;
    /**
     * 
     * @type {number}
     * @memberof LBPFeatures
     */
    'maxWalletPercent': number;
}
/**
 * 
 * @export
 * @interface LBPTransactionDto
 */
export interface LBPTransactionDto {
    /**
     * 
     * @type {string}
     * @memberof LBPTransactionDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LBPTransactionDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LBPTransactionDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'chainId': number;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'blockNumber': number;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'logIndex': number;
    /**
     * 
     * @type {string}
     * @memberof LBPTransactionDto
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof LBPTransactionDto
     */
    'type': LBPTransactionDtoTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'ethAmount': number;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'tokenAmount': number;
    /**
     * 
     * @type {string}
     * @memberof LBPTransactionDto
     */
    'from': string;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'currPrice': number;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'ethersInPool': number;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'tokensInPool': number;
    /**
     * 
     * @type {string}
     * @memberof LBPTransactionDto
     */
    'txHash': string;
    /**
     * 
     * @type {number}
     * @memberof LBPTransactionDto
     */
    'curPriceUsd': number;
}

export const LBPTransactionDtoTypeEnum = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type LBPTransactionDtoTypeEnum = typeof LBPTransactionDtoTypeEnum[keyof typeof LBPTransactionDtoTypeEnum];

/**
 * 
 * @export
 * @interface LastBuyDto
 */
export interface LastBuyDto {
    /**
     * 
     * @type {number}
     * @memberof LastBuyDto
     */
    'ethAmount': number;
    /**
     * 
     * @type {number}
     * @memberof LastBuyDto
     */
    'tokenAmount': number;
    /**
     * 
     * @type {string}
     * @memberof LastBuyDto
     */
    'buyer': string;
    /**
     * 
     * @type {string}
     * @memberof LastBuyDto
     */
    'tokenAddress': string;
    /**
     * 
     * @type {string}
     * @memberof LastBuyDto
     */
    'tokenAvatarUrl': string;
    /**
     * 
     * @type {string}
     * @memberof LastBuyDto
     */
    'tokenName': string;
    /**
     * 
     * @type {string}
     * @memberof LastBuyDto
     */
    'tokenSymbol': string;
}
/**
 * 
 * @export
 * @interface LaunchByLiquidityData
 */
export interface LaunchByLiquidityData extends LaunchParamsDto {
    /**
     * 
     * @type {number}
     * @memberof LaunchByLiquidityData
     */
    'tokens': number;
    /**
     * 
     * @type {number}
     * @memberof LaunchByLiquidityData
     */
    'ethers': number;
    /**
     * 
     * @type {string}
     * @memberof LaunchByLiquidityData
     */
    'transactionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LaunchByLiquidityData
     */
    'signed': boolean;
    /**
     * 
     * @type {string}
     * @memberof LaunchByLiquidityData
     */
    'signLinkCode'?: string;
}
/**
 * 
 * @export
 * @interface LaunchByMethodData
 */
export interface LaunchByMethodData extends LaunchParamsDto {
    /**
     * 
     * @type {number}
     * @memberof LaunchByMethodData
     */
    'methodId': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof LaunchByMethodData
     */
    'args': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LaunchByMethodData
     */
    'transactionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LaunchByMethodData
     */
    'signed': boolean;
    /**
     * 
     * @type {string}
     * @memberof LaunchByMethodData
     */
    'signLinkCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof LaunchByMethodData
     */
    'tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof LaunchByMethodData
     */
    'ethers'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LaunchByMethodData
     */
    'liqOnMethod': boolean;
}
/**
 * 
 * @export
 * @interface LaunchDataUpdateRequest
 */
export interface LaunchDataUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LaunchDataUpdateRequest
     */
    'type': LaunchDataUpdateRequestTypeEnum;
}

export const LaunchDataUpdateRequestTypeEnum = {
    Method: 'METHOD',
    Liquidity: 'LIQUIDITY'
} as const;

export type LaunchDataUpdateRequestTypeEnum = typeof LaunchDataUpdateRequestTypeEnum[keyof typeof LaunchDataUpdateRequestTypeEnum];

/**
 * 
 * @export
 * @interface LaunchParamsDto
 */
export interface LaunchParamsDto {
    /**
     * 
     * @type {string}
     * @memberof LaunchParamsDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface LaunchSignData
 */
export interface LaunchSignData extends SignData {
    /**
     * 
     * @type {string}
     * @memberof LaunchSignData
     */
    'coinAddress': string;
    /**
     * 
     * @type {string}
     * @memberof LaunchSignData
     */
    'coinName': string;
    /**
     * 
     * @type {string}
     * @memberof LaunchSignData
     */
    'coinSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof LaunchSignData
     */
    'ethAmount': number;
    /**
     * 
     * @type {string}
     * @memberof LaunchSignData
     */
    'transactionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LaunchSignData
     */
    'signed': boolean;
    /**
     * 
     * @type {string}
     * @memberof LaunchSignData
     */
    'signer'?: string;
    /**
     * 
     * @type {number}
     * @memberof LaunchSignData
     */
    'methodId': number;
    /**
     * 
     * @type {string}
     * @memberof LaunchSignData
     */
    'methodName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LaunchSignData
     */
    'args': Array<string>;
}
/**
 * 
 * @export
 * @interface LaunchTransactionMissed
 */
export interface LaunchTransactionMissed extends CoinLaunchError {
}
/**
 * 
 * @export
 * @interface ListResponseCoinDto
 */
export interface ListResponseCoinDto {
    /**
     * 
     * @type {number}
     * @memberof ListResponseCoinDto
     */
    'pageNumber': number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCoinDto
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCoinDto
     */
    'totalElements': number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCoinDto
     */
    'rowsPerPage': number;
    /**
     * 
     * @type {Array<CoinDto>}
     * @memberof ListResponseCoinDto
     */
    'items': Array<CoinDto>;
}
/**
 * 
 * @export
 * @interface ListResponseGetCoinLBPResponse
 */
export interface ListResponseGetCoinLBPResponse {
    /**
     * 
     * @type {number}
     * @memberof ListResponseGetCoinLBPResponse
     */
    'pageNumber': number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseGetCoinLBPResponse
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseGetCoinLBPResponse
     */
    'totalElements': number;
    /**
     * 
     * @type {number}
     * @memberof ListResponseGetCoinLBPResponse
     */
    'rowsPerPage': number;
    /**
     * 
     * @type {Array<GetCoinLBPResponse>}
     * @memberof ListResponseGetCoinLBPResponse
     */
    'items': Array<GetCoinLBPResponse>;
}
/**
 * 
 * @export
 * @interface Lock
 */
export interface Lock {
    /**
     * 
     * @type {string}
     * @memberof Lock
     */
    'type': LockTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Lock
     */
    'percent': number;
    /**
     * 
     * @type {number}
     * @memberof Lock
     */
    'percentBurn'?: number;
    /**
     * 
     * @type {number}
     * @memberof Lock
     */
    'percentLock'?: number;
    /**
     * 
     * @type {number}
     * @memberof Lock
     */
    'percentOwner'?: number;
    /**
     * 
     * @type {string}
     * @memberof Lock
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lock
     */
    'unlockDate'?: string;
}

export const LockTypeEnum = {
    None: 'None',
    Burn: 'Burn',
    Lock: 'Lock'
} as const;

export type LockTypeEnum = typeof LockTypeEnum[keyof typeof LockTypeEnum];

/**
 * 
 * @export
 * @interface LockParams
 */
export interface LockParams {
    /**
     * 
     * @type {number}
     * @memberof LockParams
     */
    'lockDays': number;
    /**
     * 
     * @type {string}
     * @memberof LockParams
     */
    'lockType': LockParamsLockTypeEnum;
}

export const LockParamsLockTypeEnum = {
    None: 'None',
    Burn: 'Burn',
    Lock: 'Lock'
} as const;

export type LockParamsLockTypeEnum = typeof LockParamsLockTypeEnum[keyof typeof LockParamsLockTypeEnum];

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'wallet': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'sign': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface MethodDto
 */
export interface MethodDto {
    /**
     * 
     * @type {number}
     * @memberof MethodDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MethodDto
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof MethodDto
     */
    'name': string;
    /**
     * 
     * @type {Array<MethodInputDto>}
     * @memberof MethodDto
     */
    'inputs': Array<MethodInputDto>;
    /**
     * 
     * @type {string}
     * @memberof MethodDto
     */
    'stateMutability': string;
}
/**
 * 
 * @export
 * @interface MethodInputDto
 */
export interface MethodInputDto {
    /**
     * 
     * @type {string}
     * @memberof MethodInputDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MethodInputDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface MethodNames
 */
export interface MethodNames {
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameEnableTrading'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameRemoveLimits'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameUpdateBuyFees'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameUpdateSellFees'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameSetAmmPair'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameForceSwap'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameForceSend'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameMarketingWallet'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameBlacklist'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameRenounceBlacklist'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameUpdateMaxTxAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameUpdateMaxWalletAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodNames
     */
    'nameExcludeFromMaxTransaction'?: string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {boolean}
     * @memberof Node
     */
    'connected': boolean;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'timeConnected': number;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'nodeScore': number;
}
/**
 * 
 * @export
 * @interface NodeNetStat
 */
export interface NodeNetStat {
    /**
     * 
     * @type {number}
     * @memberof NodeNetStat
     */
    'totalTasks': number;
    /**
     * 
     * @type {number}
     * @memberof NodeNetStat
     */
    'uniqueUsers': number;
    /**
     * 
     * @type {number}
     * @memberof NodeNetStat
     */
    'activeUsers': number;
    /**
     * 
     * @type {number}
     * @memberof NodeNetStat
     */
    'tasks1h': number;
    /**
     * 
     * @type {number}
     * @memberof NodeNetStat
     */
    'tasks5min': number;
    /**
     * 
     * @type {number}
     * @memberof NodeNetStat
     */
    'tasks24h': number;
    /**
     * 
     * @type {Array<NodeStatShort>}
     * @memberof NodeNetStat
     */
    'hourStats': Array<NodeStatShort>;
    /**
     * 
     * @type {Array<NodeStatShort>}
     * @memberof NodeNetStat
     */
    'minuteStats': Array<NodeStatShort>;
}
/**
 * 
 * @export
 * @interface NodeStatShort
 */
export interface NodeStatShort {
    /**
     * 
     * @type {string}
     * @memberof NodeStatShort
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof NodeStatShort
     */
    'tasks': number;
    /**
     * 
     * @type {number}
     * @memberof NodeStatShort
     */
    'users': number;
}
/**
 * 
 * @export
 * @interface Nonce
 */
export interface Nonce {
    /**
     * 
     * @type {string}
     * @memberof Nonce
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface OrderDto
 */
export interface OrderDto {
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'ethAmount': number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'tokenAmount': number;
    /**
     * 
     * @type {number}
     * @memberof OrderDto
     */
    'tokenAmountInPercent': number;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDto
     */
    'orderType': OrderDtoOrderTypeEnum;
    /**
     * 
     * @type {TransactionDto}
     * @memberof OrderDto
     */
    'transaction'?: TransactionDto;
    /**
     * 
     * @type {TransactionDto}
     * @memberof OrderDto
     */
    'bribeTransaction'?: TransactionDto;
}

export const OrderDtoOrderTypeEnum = {
    Regular: 'Regular',
    Auction: 'Auction'
} as const;

export type OrderDtoOrderTypeEnum = typeof OrderDtoOrderTypeEnum[keyof typeof OrderDtoOrderTypeEnum];

/**
 * 
 * @export
 * @interface OrderSameFrom
 */
export interface OrderSameFrom extends CoinLaunchError {
    /**
     * 
     * @type {string}
     * @memberof OrderSameFrom
     */
    'orderId': string;
}
/**
 * 
 * @export
 * @interface OrderSignData
 */
export interface OrderSignData extends SignData {
    /**
     * 
     * @type {string}
     * @memberof OrderSignData
     */
    'coinAddress': string;
    /**
     * 
     * @type {string}
     * @memberof OrderSignData
     */
    'coinName': string;
    /**
     * 
     * @type {string}
     * @memberof OrderSignData
     */
    'coinSymbol': string;
    /**
     * 
     * @type {number}
     * @memberof OrderSignData
     */
    'ethAmount': number;
    /**
     * 
     * @type {number}
     * @memberof OrderSignData
     */
    'tokenAmountPercent': number;
    /**
     * 
     * @type {string}
     * @memberof OrderSignData
     */
    'transactionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderSignData
     */
    'signed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderSignData
     */
    'methodName': string;
    /**
     * 
     * @type {string}
     * @memberof OrderSignData
     */
    'signer'?: string;
}
/**
 * 
 * @export
 * @interface OrderWithoutTx
 */
export interface OrderWithoutTx extends CoinLaunchError {
    /**
     * 
     * @type {string}
     * @memberof OrderWithoutTx
     */
    'orderId': string;
}
/**
 * 
 * @export
 * @interface OrdersIsEmpty
 */
export interface OrdersIsEmpty extends CoinLaunchError {
}
/**
 * 
 * @export
 * @interface ServiceUnpaid
 */
export interface ServiceUnpaid extends CoinLaunchError {
}
/**
 * 
 * @export
 * @interface SignData
 */
export interface SignData {
    /**
     * 
     * @type {string}
     * @memberof SignData
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface SignLaunchTransactionRequest
 */
export interface SignLaunchTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof SignLaunchTransactionRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface SignLaunchTransactionResponse
 */
export interface SignLaunchTransactionResponse {
    /**
     * 
     * @type {CoinDto}
     * @memberof SignLaunchTransactionResponse
     */
    'coin': CoinDto;
}
/**
 * 
 * @export
 * @interface SignOrderRequest
 */
export interface SignOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof SignOrderRequest
     */
    'pk': string;
}
/**
 * 
 * @export
 * @interface SignOrderRequestInner
 */
export interface SignOrderRequestInner {
    /**
     * 
     * @type {string}
     * @memberof SignOrderRequestInner
     */
    'pk': string;
    /**
     * 
     * @type {string}
     * @memberof SignOrderRequestInner
     */
    'orderId': string;
}
/**
 * 
 * @export
 * @interface SignOrderRequestMass
 */
export interface SignOrderRequestMass {
    /**
     * 
     * @type {Array<SignOrderRequestInner>}
     * @memberof SignOrderRequestMass
     */
    'requests': Array<SignOrderRequestInner>;
}
/**
 * 
 * @export
 * @interface SignTransactionRequest
 */
export interface SignTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof SignTransactionRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface SseEmitter
 */
export interface SseEmitter {
    /**
     * 
     * @type {number}
     * @memberof SseEmitter
     */
    'timeout'?: number;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {Array<number>}
     * @memberof Task
     */
    'image': Array<number>;
}
/**
 * 
 * @export
 * @interface TaskSubmitRequest
 */
export interface TaskSubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskSubmitRequest
     */
    'wallet': string;
    /**
     * 
     * @type {string}
     * @memberof TaskSubmitRequest
     */
    'mac': string;
    /**
     * 
     * @type {number}
     * @memberof TaskSubmitRequest
     */
    'prediction': number;
}
/**
 * 
 * @export
 * @interface TransactionDto
 */
export interface TransactionDto {
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'type': TransactionDtoTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'nonce': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'value': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'maxFeePerGas': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'maxPriorityFeePerGas': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'gasLimit': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'callData': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'rawData': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'hash': string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDto
     */
    'signed': boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'chainId': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionDto
     */
    'errors': Array<TransactionDtoErrorsEnum>;
}

export const TransactionDtoTypeEnum = {
    Launch: 'LAUNCH',
    Order: 'ORDER',
    Bribe: 'BRIBE'
} as const;

export type TransactionDtoTypeEnum = typeof TransactionDtoTypeEnum[keyof typeof TransactionDtoTypeEnum];
export const TransactionDtoErrorsEnum = {
    InsufficientBalance: 'INSUFFICIENT_BALANCE',
    NonceDoesNotMatch: 'NONCE_DOES_NOT_MATCH',
    NoOrderTxForBribe: 'NO_ORDER_TX_FOR_BRIBE'
} as const;

export type TransactionDtoErrorsEnum = typeof TransactionDtoErrorsEnum[keyof typeof TransactionDtoErrorsEnum];

/**
 * 
 * @export
 * @interface TransactionInvalid
 */
export interface TransactionInvalid extends CoinLaunchError {
    /**
     * 
     * @type {string}
     * @memberof TransactionInvalid
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionInvalid
     */
    'errors': Array<string>;
}
/**
 * 
 * @export
 * @interface TransactionUnsigned
 */
export interface TransactionUnsigned extends CoinLaunchError {
    /**
     * 
     * @type {string}
     * @memberof TransactionUnsigned
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UpdateAbiRequest
 */
export interface UpdateAbiRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAbiRequest
     */
    'abi': string;
}
/**
 * 
 * @export
 * @interface UpdateAbiResponse
 */
export interface UpdateAbiResponse {
    /**
     * 
     * @type {CoinDto}
     * @memberof UpdateAbiResponse
     */
    'coin': CoinDto;
}
/**
 * 
 * @export
 * @interface UpdateBribeRequest
 */
export interface UpdateBribeRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateBribeRequest
     */
    'bribe': number;
}
/**
 * @type UpdateLaunchType200Response
 * @export
 */
export type UpdateLaunchType200Response = LaunchByLiquidityData | LaunchByMethodData;

/**
 * @type UpdateLaunchTypeRequest
 * @export
 */
export type UpdateLaunchTypeRequest = ByLiquidity | ByMethod;

/**
 * 
 * @export
 * @interface UpdateMaxTxRequest
 */
export interface UpdateMaxTxRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateMaxTxRequest
     */
    'maxTxInPercent': number;
}
/**
 * 
 * @export
 * @interface UpdateMaxTxResponse
 */
export interface UpdateMaxTxResponse {
    /**
     * 
     * @type {CoinDto}
     * @memberof UpdateMaxTxResponse
     */
    'coin': CoinDto;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'bio'?: string;
}
/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'wallet': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'avatarUrl'?: string;
}
/**
 * 
 * @export
 * @interface WithdrawResult
 */
export interface WithdrawResult {
    /**
     * 
     * @type {string}
     * @memberof WithdrawResult
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawResult
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof WithdrawResult
     */
    'amount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WithdrawResult
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof WithdrawResult
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface WithdrawWallet
 */
export interface WithdrawWallet {
    /**
     * 
     * @type {string}
     * @memberof WithdrawWallet
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof WithdrawWallet
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface WithdrawWalletRequest
 */
export interface WithdrawWalletRequest {
    /**
     * 
     * @type {Array<WithdrawWallet>}
     * @memberof WithdrawWalletRequest
     */
    'wallets': Array<WithdrawWallet>;
}
/**
 * 
 * @export
 * @interface WithdrawWalletResponse
 */
export interface WithdrawWalletResponse {
    /**
     * 
     * @type {Array<WithdrawResult>}
     * @memberof WithdrawWalletResponse
     */
    'results': Array<WithdrawResult>;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/public/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonce: async (wallet: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wallet' is not null or undefined
            assertParamExists('nonce', 'wallet', wallet)
            const localVarPath = `/public/v1/auth/nonce`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wallet !== undefined) {
                localVarQueryParameter['wallet'] = wallet;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nonce(wallet: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nonce>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonce(wallet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.nonce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonce(wallet: string, options?: RawAxiosRequestConfig): AxiosPromise<Nonce> {
            return localVarFp.nonce(wallet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} wallet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public nonce(wallet: string, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).nonce(wallet, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoinControllerApi - axios parameter creator
 * @export
 */
export const CoinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} coinAddress 
         * @param {AdditionalMetadataDto} additionalMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdditionalMetadata: async (coinAddress: string, additionalMetadataDto: AdditionalMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinAddress' is not null or undefined
            assertParamExists('addAdditionalMetadata', 'coinAddress', coinAddress)
            // verify required parameter 'additionalMetadataDto' is not null or undefined
            assertParamExists('addAdditionalMetadata', 'additionalMetadataDto', additionalMetadataDto)
            const localVarPath = `/v1/coins/{coinAddress}/metadata`
                .replace(`{${"coinAddress"}}`, encodeURIComponent(String(coinAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(additionalMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPayment: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('checkPayment', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/check-paid`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkVerification: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('checkVerification', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/verification`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinEventStream: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('coinEventStream', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/events`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin: async (createCoinRequest: CreateCoinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCoinRequest' is not null or undefined
            assertParamExists('createCoin', 'createCoinRequest', createCoinRequest)
            const localVarPath = `/v1/coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCoinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLaunchTransaction: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('createLaunchTransaction', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/launch-tx`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('deleteCoin', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchTransaction: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('deleteLaunchTransaction', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/launch-tx`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {GeneratorParams} generatorParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillGeneratorParams: async (coinId: string, generatorParams: GeneratorParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('fillGeneratorParams', 'coinId', coinId)
            // verify required parameter 'generatorParams' is not null or undefined
            assertParamExists('fillGeneratorParams', 'generatorParams', generatorParams)
            const localVarPath = `/v1/coins/{coinId}/params`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generatorParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCoin: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('generateCoin', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/generate`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {GenerateCoin1Request} [generateCoin1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCoin1: async (coinId: string, generateCoin1Request?: GenerateCoin1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('generateCoin1', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/generate-by-file`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateCoin1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('getCoin', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [rowsPerPage] 
         * @param {number} [pageNum] 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoins: async (rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rowsPerPage !== undefined) {
                localVarQueryParameter['rowsPerPage'] = rowsPerPage;
            }

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchMethodTransaction: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('getLaunchMethodTransaction', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/launch-tx`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launch: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('launch', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/launch`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadCoin: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('reloadCoin', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/reload`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {SignLaunchTransactionRequest} signLaunchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signLaunchTransaction: async (coinId: string, signLaunchTransactionRequest: SignLaunchTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('signLaunchTransaction', 'coinId', coinId)
            // verify required parameter 'signLaunchTransactionRequest' is not null or undefined
            assertParamExists('signLaunchTransaction', 'signLaunchTransactionRequest', signLaunchTransactionRequest)
            const localVarPath = `/v1/coins/{coinId}/sign-launch-tx`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signLaunchTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateAbiRequest} updateAbiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAbi: async (coinId: string, updateAbiRequest: UpdateAbiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateAbi', 'coinId', coinId)
            // verify required parameter 'updateAbiRequest' is not null or undefined
            assertParamExists('updateAbi', 'updateAbiRequest', updateAbiRequest)
            const localVarPath = `/v1/coins/{coinId}/abi`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAbiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {AuctionStateRequest} auctionStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuctionState: async (coinId: string, auctionStateRequest: AuctionStateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateAuctionState', 'coinId', coinId)
            // verify required parameter 'auctionStateRequest' is not null or undefined
            assertParamExists('updateAuctionState', 'auctionStateRequest', auctionStateRequest)
            const localVarPath = `/v1/coins/{coinId}/auction-state`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(auctionStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {BundleTypeUpdateRequest} bundleTypeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBundleType: async (coinId: string, bundleTypeUpdateRequest: BundleTypeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateBundleType', 'coinId', coinId)
            // verify required parameter 'bundleTypeUpdateRequest' is not null or undefined
            assertParamExists('updateBundleType', 'bundleTypeUpdateRequest', bundleTypeUpdateRequest)
            const localVarPath = `/v1/coins/{coinId}/bundle-type`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bundleTypeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {DeployCoinRequest} deployCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoinWithDeployed: async (coinId: string, deployCoinRequest: DeployCoinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateCoinWithDeployed', 'coinId', coinId)
            // verify required parameter 'deployCoinRequest' is not null or undefined
            assertParamExists('updateCoinWithDeployed', 'deployCoinRequest', deployCoinRequest)
            const localVarPath = `/v1/coins/{coinId}/deployed`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployCoinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} newStep 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoinWithDeployed1: async (coinId: string, newStep: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateCoinWithDeployed1', 'coinId', coinId)
            // verify required parameter 'newStep' is not null or undefined
            assertParamExists('updateCoinWithDeployed1', 'newStep', newStep)
            const localVarPath = `/v1/coins/{coinId}/change-step/{newStep}`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)))
                .replace(`{${"newStep"}}`, encodeURIComponent(String(newStep)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateLaunchTypeRequest} updateLaunchTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchType: async (coinId: string, updateLaunchTypeRequest: UpdateLaunchTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateLaunchType', 'coinId', coinId)
            // verify required parameter 'updateLaunchTypeRequest' is not null or undefined
            assertParamExists('updateLaunchType', 'updateLaunchTypeRequest', updateLaunchTypeRequest)
            const localVarPath = `/v1/coins/{coinId}/launch-type`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLaunchTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateMaxTxRequest} updateMaxTxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaxTx: async (coinId: string, updateMaxTxRequest: UpdateMaxTxRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateMaxTx', 'coinId', coinId)
            // verify required parameter 'updateMaxTxRequest' is not null or undefined
            assertParamExists('updateMaxTx', 'updateMaxTxRequest', updateMaxTxRequest)
            const localVarPath = `/v1/coins/{coinId}/tx`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMaxTxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('verify', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/verify`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoinControllerApi - functional programming interface
 * @export
 */
export const CoinControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoinControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} coinAddress 
         * @param {AdditionalMetadataDto} additionalMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAdditionalMetadata(coinAddress: string, additionalMetadataDto: AdditionalMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAdditionalMetadata(coinAddress, additionalMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.addAdditionalMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPayment(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPayment(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.checkPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkVerification(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkVerification(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.checkVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coinEventStream(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SseEmitter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coinEventStream(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.coinEventStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoin(createCoinRequest: CreateCoinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCoin(createCoinRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.createCoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLaunchTransaction(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLaunchMethodTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLaunchTransaction(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.createLaunchTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoin(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCoin(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.deleteCoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLaunchTransaction(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteLaunchTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLaunchTransaction(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.deleteLaunchTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {GeneratorParams} generatorParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fillGeneratorParams(coinId: string, generatorParams: GeneratorParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fillGeneratorParams(coinId, generatorParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.fillGeneratorParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCoin(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCoin(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.generateCoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {GenerateCoin1Request} [generateCoin1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCoin1(coinId: string, generateCoin1Request?: GenerateCoin1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCoin1(coinId, generateCoin1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.generateCoin1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCoinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoin(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.getCoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [rowsPerPage] 
         * @param {number} [pageNum] 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoins(rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseCoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoins(rowsPerPage, pageNum, sortBy, sortDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.getCoins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLaunchMethodTransaction(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLaunchMethodTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLaunchMethodTransaction(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.getLaunchMethodTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async launch(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinLaunchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.launch(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.launch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reloadCoin(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadCoin(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.reloadCoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {SignLaunchTransactionRequest} signLaunchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signLaunchTransaction(coinId: string, signLaunchTransactionRequest: SignLaunchTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignLaunchTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signLaunchTransaction(coinId, signLaunchTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.signLaunchTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateAbiRequest} updateAbiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAbi(coinId: string, updateAbiRequest: UpdateAbiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAbiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAbi(coinId, updateAbiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.updateAbi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {AuctionStateRequest} auctionStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAuctionState(coinId: string, auctionStateRequest: AuctionStateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAuctionState(coinId, auctionStateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.updateAuctionState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {BundleTypeUpdateRequest} bundleTypeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBundleType(coinId: string, bundleTypeUpdateRequest: BundleTypeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBundleType(coinId, bundleTypeUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.updateBundleType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {DeployCoinRequest} deployCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCoinWithDeployed(coinId: string, deployCoinRequest: DeployCoinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCoinWithDeployed(coinId, deployCoinRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.updateCoinWithDeployed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} newStep 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCoinWithDeployed1(coinId: string, newStep: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCoinWithDeployed1(coinId, newStep, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.updateCoinWithDeployed1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateLaunchTypeRequest} updateLaunchTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLaunchType(coinId: string, updateLaunchTypeRequest: UpdateLaunchTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateLaunchType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLaunchType(coinId, updateLaunchTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.updateLaunchType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateMaxTxRequest} updateMaxTxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMaxTx(coinId: string, updateMaxTxRequest: UpdateMaxTxRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMaxTxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMaxTx(coinId, updateMaxTxRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.updateMaxTx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinControllerApi.verify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoinControllerApi - factory interface
 * @export
 */
export const CoinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoinControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} coinAddress 
         * @param {AdditionalMetadataDto} additionalMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdditionalMetadata(coinAddress: string, additionalMetadataDto: AdditionalMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addAdditionalMetadata(coinAddress, additionalMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPayment(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.checkPayment(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkVerification(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckVerificationResponse> {
            return localVarFp.checkVerification(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinEventStream(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<SseEmitter> {
            return localVarFp.coinEventStream(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin(createCoinRequest: CreateCoinRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.createCoin(createCoinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLaunchTransaction(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLaunchMethodTransactionResponse> {
            return localVarFp.createLaunchTransaction(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCoin(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchTransaction(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteLaunchTransactionResponse> {
            return localVarFp.deleteLaunchTransaction(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {GeneratorParams} generatorParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillGeneratorParams(coinId: string, generatorParams: GeneratorParams, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.fillGeneratorParams(coinId, generatorParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCoin(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.generateCoin(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {GenerateCoin1Request} [generateCoin1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCoin1(coinId: string, generateCoin1Request?: GenerateCoin1Request, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.generateCoin1(coinId, generateCoin1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCoinResponse> {
            return localVarFp.getCoin(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [rowsPerPage] 
         * @param {number} [pageNum] 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoins(rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseCoinDto> {
            return localVarFp.getCoins(rowsPerPage, pageNum, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchMethodTransaction(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLaunchMethodTransactionResponse> {
            return localVarFp.getLaunchMethodTransaction(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launch(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<CoinLaunchResponse> {
            return localVarFp.launch(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadCoin(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.reloadCoin(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {SignLaunchTransactionRequest} signLaunchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signLaunchTransaction(coinId: string, signLaunchTransactionRequest: SignLaunchTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SignLaunchTransactionResponse> {
            return localVarFp.signLaunchTransaction(coinId, signLaunchTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateAbiRequest} updateAbiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAbi(coinId: string, updateAbiRequest: UpdateAbiRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateAbiResponse> {
            return localVarFp.updateAbi(coinId, updateAbiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {AuctionStateRequest} auctionStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuctionState(coinId: string, auctionStateRequest: AuctionStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.updateAuctionState(coinId, auctionStateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {BundleTypeUpdateRequest} bundleTypeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBundleType(coinId: string, bundleTypeUpdateRequest: BundleTypeUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.updateBundleType(coinId, bundleTypeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {DeployCoinRequest} deployCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoinWithDeployed(coinId: string, deployCoinRequest: DeployCoinRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.updateCoinWithDeployed(coinId, deployCoinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} newStep 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoinWithDeployed1(coinId: string, newStep: string, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.updateCoinWithDeployed1(coinId, newStep, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateLaunchTypeRequest} updateLaunchTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchType(coinId: string, updateLaunchTypeRequest: UpdateLaunchTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateLaunchType200Response> {
            return localVarFp.updateLaunchType(coinId, updateLaunchTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateMaxTxRequest} updateMaxTxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaxTx(coinId: string, updateMaxTxRequest: UpdateMaxTxRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateMaxTxResponse> {
            return localVarFp.updateMaxTx(coinId, updateMaxTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<CoinDto> {
            return localVarFp.verify(coinId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoinControllerApi - object-oriented interface
 * @export
 * @class CoinControllerApi
 * @extends {BaseAPI}
 */
export class CoinControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} coinAddress 
     * @param {AdditionalMetadataDto} additionalMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public addAdditionalMetadata(coinAddress: string, additionalMetadataDto: AdditionalMetadataDto, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).addAdditionalMetadata(coinAddress, additionalMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public checkPayment(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).checkPayment(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public checkVerification(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).checkVerification(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public coinEventStream(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).coinEventStream(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCoinRequest} createCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public createCoin(createCoinRequest: CreateCoinRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).createCoin(createCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public createLaunchTransaction(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).createLaunchTransaction(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public deleteCoin(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).deleteCoin(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public deleteLaunchTransaction(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).deleteLaunchTransaction(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {GeneratorParams} generatorParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public fillGeneratorParams(coinId: string, generatorParams: GeneratorParams, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).fillGeneratorParams(coinId, generatorParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public generateCoin(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).generateCoin(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {GenerateCoin1Request} [generateCoin1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public generateCoin1(coinId: string, generateCoin1Request?: GenerateCoin1Request, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).generateCoin1(coinId, generateCoin1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public getCoin(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).getCoin(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [rowsPerPage] 
     * @param {number} [pageNum] 
     * @param {string} [sortBy] 
     * @param {string} [sortDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public getCoins(rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).getCoins(rowsPerPage, pageNum, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public getLaunchMethodTransaction(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).getLaunchMethodTransaction(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public launch(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).launch(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public reloadCoin(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).reloadCoin(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {SignLaunchTransactionRequest} signLaunchTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public signLaunchTransaction(coinId: string, signLaunchTransactionRequest: SignLaunchTransactionRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).signLaunchTransaction(coinId, signLaunchTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {UpdateAbiRequest} updateAbiRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public updateAbi(coinId: string, updateAbiRequest: UpdateAbiRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).updateAbi(coinId, updateAbiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {AuctionStateRequest} auctionStateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public updateAuctionState(coinId: string, auctionStateRequest: AuctionStateRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).updateAuctionState(coinId, auctionStateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {BundleTypeUpdateRequest} bundleTypeUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public updateBundleType(coinId: string, bundleTypeUpdateRequest: BundleTypeUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).updateBundleType(coinId, bundleTypeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {DeployCoinRequest} deployCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public updateCoinWithDeployed(coinId: string, deployCoinRequest: DeployCoinRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).updateCoinWithDeployed(coinId, deployCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {string} newStep 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public updateCoinWithDeployed1(coinId: string, newStep: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).updateCoinWithDeployed1(coinId, newStep, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {UpdateLaunchTypeRequest} updateLaunchTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public updateLaunchType(coinId: string, updateLaunchTypeRequest: UpdateLaunchTypeRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).updateLaunchType(coinId, updateLaunchTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {UpdateMaxTxRequest} updateMaxTxRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public updateMaxTx(coinId: string, updateMaxTxRequest: UpdateMaxTxRequest, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).updateMaxTx(coinId, updateMaxTxRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public verify(coinId: string, options?: RawAxiosRequestConfig) {
        return CoinControllerApiFp(this.configuration).verify(coinId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoinPublicControllerApi - axios parameter creator
 * @export
 */
export const CoinPublicControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} coinAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin1: async (coinAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinAddress' is not null or undefined
            assertParamExists('getCoin1', 'coinAddress', coinAddress)
            const localVarPath = `/public/v1/coins/{coinAddress}`
                .replace(`{${"coinAddress"}}`, encodeURIComponent(String(coinAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinLbpCoin: async (coinAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinAddress' is not null or undefined
            assertParamExists('getCoinLbpCoin', 'coinAddress', coinAddress)
            const localVarPath = `/public/v1/coins/{coinAddress}/lbp`
                .replace(`{${"coinAddress"}}`, encodeURIComponent(String(coinAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [searchRequest] 
         * @param {GetCoins1LockTypeEnum} [lockType] 
         * @param {GetCoins1PoolTypeEnum} [poolType] 
         * @param {number} [targetLiquidity] 
         * @param {boolean} [listed] 
         * @param {number} [rowsPerPage] 
         * @param {number} [pageNum] 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoins1: async (searchRequest?: string, lockType?: GetCoins1LockTypeEnum, poolType?: GetCoins1PoolTypeEnum, targetLiquidity?: number, listed?: boolean, rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/v1/coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchRequest !== undefined) {
                localVarQueryParameter['searchRequest'] = searchRequest;
            }

            if (lockType !== undefined) {
                localVarQueryParameter['lockType'] = lockType;
            }

            if (poolType !== undefined) {
                localVarQueryParameter['poolType'] = poolType;
            }

            if (targetLiquidity !== undefined) {
                localVarQueryParameter['targetLiquidity'] = targetLiquidity;
            }

            if (listed !== undefined) {
                localVarQueryParameter['listed'] = listed;
            }

            if (rowsPerPage !== undefined) {
                localVarQueryParameter['rowsPerPage'] = rowsPerPage;
            }

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBuys: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/v1/coins/last-lbp-buys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoinPublicControllerApi - functional programming interface
 * @export
 */
export const CoinPublicControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoinPublicControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} coinAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin1(coinAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCoinBasicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoin1(coinAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinPublicControllerApi.getCoin1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoinLbpCoin(coinAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCoinLBPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoinLbpCoin(coinAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinPublicControllerApi.getCoinLbpCoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [searchRequest] 
         * @param {GetCoins1LockTypeEnum} [lockType] 
         * @param {GetCoins1PoolTypeEnum} [poolType] 
         * @param {number} [targetLiquidity] 
         * @param {boolean} [listed] 
         * @param {number} [rowsPerPage] 
         * @param {number} [pageNum] 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoins1(searchRequest?: string, lockType?: GetCoins1LockTypeEnum, poolType?: GetCoins1PoolTypeEnum, targetLiquidity?: number, listed?: boolean, rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseGetCoinLBPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoins1(searchRequest, lockType, poolType, targetLiquidity, listed, rowsPerPage, pageNum, sortBy, sortDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinPublicControllerApi.getCoins1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastBuys(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLastBuysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastBuys(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoinPublicControllerApi.getLastBuys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoinPublicControllerApi - factory interface
 * @export
 */
export const CoinPublicControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoinPublicControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} coinAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin1(coinAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCoinBasicResponse> {
            return localVarFp.getCoin1(coinAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinLbpCoin(coinAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCoinLBPResponse> {
            return localVarFp.getCoinLbpCoin(coinAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [searchRequest] 
         * @param {GetCoins1LockTypeEnum} [lockType] 
         * @param {GetCoins1PoolTypeEnum} [poolType] 
         * @param {number} [targetLiquidity] 
         * @param {boolean} [listed] 
         * @param {number} [rowsPerPage] 
         * @param {number} [pageNum] 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoins1(searchRequest?: string, lockType?: GetCoins1LockTypeEnum, poolType?: GetCoins1PoolTypeEnum, targetLiquidity?: number, listed?: boolean, rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseGetCoinLBPResponse> {
            return localVarFp.getCoins1(searchRequest, lockType, poolType, targetLiquidity, listed, rowsPerPage, pageNum, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBuys(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetLastBuysResponse> {
            return localVarFp.getLastBuys(limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoinPublicControllerApi - object-oriented interface
 * @export
 * @class CoinPublicControllerApi
 * @extends {BaseAPI}
 */
export class CoinPublicControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} coinAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinPublicControllerApi
     */
    public getCoin1(coinAddress: string, options?: RawAxiosRequestConfig) {
        return CoinPublicControllerApiFp(this.configuration).getCoin1(coinAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinPublicControllerApi
     */
    public getCoinLbpCoin(coinAddress: string, options?: RawAxiosRequestConfig) {
        return CoinPublicControllerApiFp(this.configuration).getCoinLbpCoin(coinAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [searchRequest] 
     * @param {GetCoins1LockTypeEnum} [lockType] 
     * @param {GetCoins1PoolTypeEnum} [poolType] 
     * @param {number} [targetLiquidity] 
     * @param {boolean} [listed] 
     * @param {number} [rowsPerPage] 
     * @param {number} [pageNum] 
     * @param {string} [sortBy] 
     * @param {string} [sortDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinPublicControllerApi
     */
    public getCoins1(searchRequest?: string, lockType?: GetCoins1LockTypeEnum, poolType?: GetCoins1PoolTypeEnum, targetLiquidity?: number, listed?: boolean, rowsPerPage?: number, pageNum?: number, sortBy?: string, sortDirection?: string, options?: RawAxiosRequestConfig) {
        return CoinPublicControllerApiFp(this.configuration).getCoins1(searchRequest, lockType, poolType, targetLiquidity, listed, rowsPerPage, pageNum, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinPublicControllerApi
     */
    public getLastBuys(limit?: number, options?: RawAxiosRequestConfig) {
        return CoinPublicControllerApiFp(this.configuration).getLastBuys(limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCoins1LockTypeEnum = {
    None: 'None',
    Burn: 'Burn',
    Lock: 'Lock'
} as const;
export type GetCoins1LockTypeEnum = typeof GetCoins1LockTypeEnum[keyof typeof GetCoins1LockTypeEnum];
/**
 * @export
 */
export const GetCoins1PoolTypeEnum = {
    UniswapV2: 'UNISWAP_V2',
    Vista: 'VISTA',
    UniswapV3: 'UNISWAP_V3'
} as const;
export type GetCoins1PoolTypeEnum = typeof GetCoins1PoolTypeEnum[keyof typeof GetCoins1PoolTypeEnum];


/**
 * CommentControllerApi - axios parameter creator
 * @export
 */
export const CommentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (createCommentRequest: CreateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCommentRequest' is not null or undefined
            assertParamExists('createComment', 'createCommentRequest', createCommentRequest)
            const localVarPath = `/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteComment', 'commentId', commentId)
            const localVarPath = `/v1/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentControllerApi - functional programming interface
 * @export
 */
export const CommentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(createCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.createComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.deleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentControllerApi - factory interface
 * @export
 */
export const CommentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentDto> {
            return localVarFp.createComment(createCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(commentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComment(commentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentControllerApi - object-oriented interface
 * @export
 * @class CommentControllerApi
 * @extends {BaseAPI}
 */
export class CommentControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCommentRequest} createCommentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public createComment(createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).createComment(createCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public deleteComment(commentId: string, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).deleteComment(commentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileControllerApi - axios parameter creator
 * @export
 */
export const FileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            const localVarPath = `/public/v1/file/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileControllerApi - functional programming interface
 * @export
 */
export const FileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileControllerApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileControllerApi - factory interface
 * @export
 */
export const FileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file: File, options?: RawAxiosRequestConfig): AxiosPromise<UploadFileResponse> {
            return localVarFp.uploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileControllerApi - object-oriented interface
 * @export
 * @class FileControllerApi
 * @extends {BaseAPI}
 */
export class FileControllerApi extends BaseAPI {
    /**
     * 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public uploadFile(file: File, options?: RawAxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileStatControllerApi - axios parameter creator
 * @export
 */
export const FileStatControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboard: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/v1/grid/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTasks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/v1/grid/generate-task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/v1/grid/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TaskSubmitRequest} taskSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTask: async (taskSubmitRequest: TaskSubmitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskSubmitRequest' is not null or undefined
            assertParamExists('submitTask', 'taskSubmitRequest', taskSubmitRequest)
            const localVarPath = `/public/v1/grid/submit-task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskSubmitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDashboard: async (wallet: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wallet' is not null or undefined
            assertParamExists('userDashboard', 'wallet', wallet)
            const localVarPath = `/public/v1/grid/me-dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wallet !== undefined) {
                localVarQueryParameter['wallet'] = wallet;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileStatControllerApi - functional programming interface
 * @export
 */
export const FileStatControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileStatControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboard(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboard(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileStatControllerApi.dashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTasks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTasks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileStatControllerApi.generateTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeNetStat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileStatControllerApi.networkStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TaskSubmitRequest} taskSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitTask(taskSubmitRequest: TaskSubmitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTask(taskSubmitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileStatControllerApi.submitTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDashboard(wallet: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDashboard(wallet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileStatControllerApi.userDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileStatControllerApi - factory interface
 * @export
 */
export const FileStatControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileStatControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboard(options?: RawAxiosRequestConfig): AxiosPromise<Dashboard> {
            return localVarFp.dashboard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTasks(options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.generateTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkStats(options?: RawAxiosRequestConfig): AxiosPromise<NodeNetStat> {
            return localVarFp.networkStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskSubmitRequest} taskSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTask(taskSubmitRequest: TaskSubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitTask(taskSubmitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDashboard(wallet: string, options?: RawAxiosRequestConfig): AxiosPromise<Dashboard> {
            return localVarFp.userDashboard(wallet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileStatControllerApi - object-oriented interface
 * @export
 * @class FileStatControllerApi
 * @extends {BaseAPI}
 */
export class FileStatControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStatControllerApi
     */
    public dashboard(options?: RawAxiosRequestConfig) {
        return FileStatControllerApiFp(this.configuration).dashboard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStatControllerApi
     */
    public generateTasks(options?: RawAxiosRequestConfig) {
        return FileStatControllerApiFp(this.configuration).generateTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStatControllerApi
     */
    public networkStats(options?: RawAxiosRequestConfig) {
        return FileStatControllerApiFp(this.configuration).networkStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskSubmitRequest} taskSubmitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStatControllerApi
     */
    public submitTask(taskSubmitRequest: TaskSubmitRequest, options?: RawAxiosRequestConfig) {
        return FileStatControllerApiFp(this.configuration).submitTask(taskSubmitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} wallet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStatControllerApi
     */
    public userDashboard(wallet: string, options?: RawAxiosRequestConfig) {
        return FileStatControllerApiFp(this.configuration).userDashboard(wallet, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LaundryPublicControllerApi - axios parameter creator
 * @export
 */
export const LaundryPublicControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DoCexWithdrawTypeEnum} type 
         * @param {WithdrawWalletRequest} withdrawWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doCexWithdraw: async (type: DoCexWithdrawTypeEnum, withdrawWalletRequest: WithdrawWalletRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('doCexWithdraw', 'type', type)
            // verify required parameter 'withdrawWalletRequest' is not null or undefined
            assertParamExists('doCexWithdraw', 'withdrawWalletRequest', withdrawWalletRequest)
            const localVarPath = `/v1/lndry/cex/{type}/withdraw`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetCexBalanceTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCexBalance: async (type: GetCexBalanceTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getCexBalance', 'type', type)
            const localVarPath = `/v1/lndry/cex/{type}/balance`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetCexSettingsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCexSettings: async (type: GetCexSettingsTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getCexSettings', 'type', type)
            const localVarPath = `/v1/lndry/cex/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetCexSettingsTypeEnum} type 
         * @param {CexSettings} cexSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCexSettings: async (type: SetCexSettingsTypeEnum, cexSettings: CexSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('setCexSettings', 'type', type)
            // verify required parameter 'cexSettings' is not null or undefined
            assertParamExists('setCexSettings', 'cexSettings', cexSettings)
            const localVarPath = `/v1/lndry/cex/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cexSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LaundryPublicControllerApi - functional programming interface
 * @export
 */
export const LaundryPublicControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LaundryPublicControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DoCexWithdrawTypeEnum} type 
         * @param {WithdrawWalletRequest} withdrawWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doCexWithdraw(type: DoCexWithdrawTypeEnum, withdrawWalletRequest: WithdrawWalletRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doCexWithdraw(type, withdrawWalletRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LaundryPublicControllerApi.doCexWithdraw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetCexBalanceTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCexBalance(type: GetCexBalanceTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CexBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCexBalance(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LaundryPublicControllerApi.getCexBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetCexSettingsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCexSettings(type: GetCexSettingsTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CexSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCexSettings(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LaundryPublicControllerApi.getCexSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetCexSettingsTypeEnum} type 
         * @param {CexSettings} cexSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCexSettings(type: SetCexSettingsTypeEnum, cexSettings: CexSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CexBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCexSettings(type, cexSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LaundryPublicControllerApi.setCexSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LaundryPublicControllerApi - factory interface
 * @export
 */
export const LaundryPublicControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LaundryPublicControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {DoCexWithdrawTypeEnum} type 
         * @param {WithdrawWalletRequest} withdrawWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doCexWithdraw(type: DoCexWithdrawTypeEnum, withdrawWalletRequest: WithdrawWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawWalletResponse> {
            return localVarFp.doCexWithdraw(type, withdrawWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetCexBalanceTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCexBalance(type: GetCexBalanceTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<CexBalanceResponse> {
            return localVarFp.getCexBalance(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetCexSettingsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCexSettings(type: GetCexSettingsTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<CexSettings> {
            return localVarFp.getCexSettings(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetCexSettingsTypeEnum} type 
         * @param {CexSettings} cexSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCexSettings(type: SetCexSettingsTypeEnum, cexSettings: CexSettings, options?: RawAxiosRequestConfig): AxiosPromise<CexBalanceResponse> {
            return localVarFp.setCexSettings(type, cexSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LaundryPublicControllerApi - object-oriented interface
 * @export
 * @class LaundryPublicControllerApi
 * @extends {BaseAPI}
 */
export class LaundryPublicControllerApi extends BaseAPI {
    /**
     * 
     * @param {DoCexWithdrawTypeEnum} type 
     * @param {WithdrawWalletRequest} withdrawWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaundryPublicControllerApi
     */
    public doCexWithdraw(type: DoCexWithdrawTypeEnum, withdrawWalletRequest: WithdrawWalletRequest, options?: RawAxiosRequestConfig) {
        return LaundryPublicControllerApiFp(this.configuration).doCexWithdraw(type, withdrawWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetCexBalanceTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaundryPublicControllerApi
     */
    public getCexBalance(type: GetCexBalanceTypeEnum, options?: RawAxiosRequestConfig) {
        return LaundryPublicControllerApiFp(this.configuration).getCexBalance(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetCexSettingsTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaundryPublicControllerApi
     */
    public getCexSettings(type: GetCexSettingsTypeEnum, options?: RawAxiosRequestConfig) {
        return LaundryPublicControllerApiFp(this.configuration).getCexSettings(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetCexSettingsTypeEnum} type 
     * @param {CexSettings} cexSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaundryPublicControllerApi
     */
    public setCexSettings(type: SetCexSettingsTypeEnum, cexSettings: CexSettings, options?: RawAxiosRequestConfig) {
        return LaundryPublicControllerApiFp(this.configuration).setCexSettings(type, cexSettings, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DoCexWithdrawTypeEnum = {
    Mexc: 'MEXC'
} as const;
export type DoCexWithdrawTypeEnum = typeof DoCexWithdrawTypeEnum[keyof typeof DoCexWithdrawTypeEnum];
/**
 * @export
 */
export const GetCexBalanceTypeEnum = {
    Mexc: 'MEXC'
} as const;
export type GetCexBalanceTypeEnum = typeof GetCexBalanceTypeEnum[keyof typeof GetCexBalanceTypeEnum];
/**
 * @export
 */
export const GetCexSettingsTypeEnum = {
    Mexc: 'MEXC'
} as const;
export type GetCexSettingsTypeEnum = typeof GetCexSettingsTypeEnum[keyof typeof GetCexSettingsTypeEnum];
/**
 * @export
 */
export const SetCexSettingsTypeEnum = {
    Mexc: 'MEXC'
} as const;
export type SetCexSettingsTypeEnum = typeof SetCexSettingsTypeEnum[keyof typeof SetCexSettingsTypeEnum];


/**
 * NftControllerApi - axios parameter creator
 * @export
 */
export const NftControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} coinId 
         * @param {CheckerRequest} checkerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkNftLink: async (coinId: string, checkerRequest: CheckerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('checkNftLink', 'coinId', coinId)
            // verify required parameter 'checkerRequest' is not null or undefined
            assertParamExists('checkNftLink', 'checkerRequest', checkerRequest)
            const localVarPath = `/v1/nft/{coinId}/check-link`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NftControllerApi - functional programming interface
 * @export
 */
export const NftControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NftControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} coinId 
         * @param {CheckerRequest} checkerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkNftLink(coinId: string, checkerRequest: CheckerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkNftLink(coinId, checkerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NftControllerApi.checkNftLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NftControllerApi - factory interface
 * @export
 */
export const NftControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NftControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} coinId 
         * @param {CheckerRequest} checkerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkNftLink(coinId: string, checkerRequest: CheckerRequest, options?: RawAxiosRequestConfig): AxiosPromise<CheckerResponse> {
            return localVarFp.checkNftLink(coinId, checkerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NftControllerApi - object-oriented interface
 * @export
 * @class NftControllerApi
 * @extends {BaseAPI}
 */
export class NftControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} coinId 
     * @param {CheckerRequest} checkerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftControllerApi
     */
    public checkNftLink(coinId: string, checkerRequest: CheckerRequest, options?: RawAxiosRequestConfig) {
        return NftControllerApiFp(this.configuration).checkNftLink(coinId, checkerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderControllerApi - axios parameter creator
 * @export
 */
export const OrderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAuctionOrder: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('addAuctionOrder', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/orders/auction-order`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {AddOrderRequest} addOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrder: async (coinId: string, addOrderRequest: AddOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('addOrder', 'coinId', coinId)
            // verify required parameter 'addOrderRequest' is not null or undefined
            assertParamExists('addOrder', 'addOrderRequest', addOrderRequest)
            const localVarPath = `/v1/coins/{coinId}/orders`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuctionOrder: async (coinId: string, orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('deleteAuctionOrder', 'coinId', coinId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('deleteAuctionOrder', 'orderId', orderId)
            const localVarPath = `/v1/coins/{coinId}/orders/auction-order/{orderId}`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (coinId: string, orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('deleteOrder', 'coinId', coinId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('deleteOrder', 'orderId', orderId)
            const localVarPath = `/v1/coins/{coinId}/orders/{orderId}`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionOrder: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('getAuctionOrder', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/orders/auction-order`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionOrderBribe: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('getAuctionOrderBribe', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/orders/auction-order/bribe`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionOrders: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('getAuctionOrders', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/orders/auction`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionStats: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('getAuctionStats', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/orders/auction/stats`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (coinId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('getOrders', 'coinId', coinId)
            const localVarPath = `/v1/coins/{coinId}/orders`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {SignOrderRequestMass} signOrderRequestMass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signMassOrder: async (coinId: string, signOrderRequestMass: SignOrderRequestMass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('signMassOrder', 'coinId', coinId)
            // verify required parameter 'signOrderRequestMass' is not null or undefined
            assertParamExists('signMassOrder', 'signOrderRequestMass', signOrderRequestMass)
            const localVarPath = `/v1/coins/{coinId}/orders/sign-mass`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signOrderRequestMass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {SignOrderRequest} signOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOrder: async (coinId: string, orderId: string, signOrderRequest: SignOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('signOrder', 'coinId', coinId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('signOrder', 'orderId', orderId)
            // verify required parameter 'signOrderRequest' is not null or undefined
            assertParamExists('signOrder', 'signOrderRequest', signOrderRequest)
            const localVarPath = `/v1/coins/{coinId}/orders/{orderId}/sign`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateBribeRequest} updateBribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuctionOrderBribe: async (coinId: string, updateBribeRequest: UpdateBribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            assertParamExists('updateAuctionOrderBribe', 'coinId', coinId)
            // verify required parameter 'updateBribeRequest' is not null or undefined
            assertParamExists('updateAuctionOrderBribe', 'updateBribeRequest', updateBribeRequest)
            const localVarPath = `/v1/coins/{coinId}/orders/auction-order/bribe`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderControllerApi - functional programming interface
 * @export
 */
export const OrderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAuctionOrder(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuctionOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAuctionOrder(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.addAuctionOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {AddOrderRequest} addOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrder(coinId: string, addOrderRequest: AddOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrder(coinId, addOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.addOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuctionOrder(coinId: string, orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuctionOrder(coinId, orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.deleteAuctionOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(coinId: string, orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(coinId, orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.deleteOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuctionOrder(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuctionOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuctionOrder(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.getAuctionOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuctionOrderBribe(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BribeSignData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuctionOrderBribe(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.getAuctionOrderBribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuctionOrders(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuctionOrders(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.getAuctionOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuctionStats(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuctionStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuctionStats(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.getAuctionStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(coinId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(coinId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {SignOrderRequestMass} signOrderRequestMass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signMassOrder(coinId: string, signOrderRequestMass: SignOrderRequestMass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signMassOrder(coinId, signOrderRequestMass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.signMassOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {SignOrderRequest} signOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signOrder(coinId: string, orderId: string, signOrderRequest: SignOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOrder(coinId, orderId, signOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.signOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateBribeRequest} updateBribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAuctionOrderBribe(coinId: string, updateBribeRequest: UpdateBribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BribeSignData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAuctionOrderBribe(coinId, updateBribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.updateAuctionOrderBribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderControllerApi - factory interface
 * @export
 */
export const OrderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAuctionOrder(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<AuctionOrder> {
            return localVarFp.addAuctionOrder(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {AddOrderRequest} addOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrder(coinId: string, addOrderRequest: AddOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddOrderResponse> {
            return localVarFp.addOrder(coinId, addOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuctionOrder(coinId: string, orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAuctionOrder(coinId, orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(coinId: string, orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrder(coinId, orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionOrder(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<AuctionOrder> {
            return localVarFp.getAuctionOrder(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionOrderBribe(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<BribeSignData> {
            return localVarFp.getAuctionOrderBribe(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionOrders(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetOrdersResponse> {
            return localVarFp.getAuctionOrders(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuctionStats(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<AuctionStatsResponse> {
            return localVarFp.getAuctionStats(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(coinId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetOrdersResponse> {
            return localVarFp.getOrders(coinId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {SignOrderRequestMass} signOrderRequestMass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signMassOrder(coinId: string, signOrderRequestMass: SignOrderRequestMass, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signMassOrder(coinId, signOrderRequestMass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {string} orderId 
         * @param {SignOrderRequest} signOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOrder(coinId: string, orderId: string, signOrderRequest: SignOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signOrder(coinId, orderId, signOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coinId 
         * @param {UpdateBribeRequest} updateBribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuctionOrderBribe(coinId: string, updateBribeRequest: UpdateBribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<BribeSignData> {
            return localVarFp.updateAuctionOrderBribe(coinId, updateBribeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderControllerApi - object-oriented interface
 * @export
 * @class OrderControllerApi
 * @extends {BaseAPI}
 */
export class OrderControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public addAuctionOrder(coinId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).addAuctionOrder(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {AddOrderRequest} addOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public addOrder(coinId: string, addOrderRequest: AddOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).addOrder(coinId, addOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public deleteAuctionOrder(coinId: string, orderId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).deleteAuctionOrder(coinId, orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public deleteOrder(coinId: string, orderId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).deleteOrder(coinId, orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getAuctionOrder(coinId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getAuctionOrder(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getAuctionOrderBribe(coinId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getAuctionOrderBribe(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getAuctionOrders(coinId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getAuctionOrders(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getAuctionStats(coinId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getAuctionStats(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getOrders(coinId: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getOrders(coinId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {SignOrderRequestMass} signOrderRequestMass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public signMassOrder(coinId: string, signOrderRequestMass: SignOrderRequestMass, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).signMassOrder(coinId, signOrderRequestMass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {string} orderId 
     * @param {SignOrderRequest} signOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public signOrder(coinId: string, orderId: string, signOrderRequest: SignOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).signOrder(coinId, orderId, signOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coinId 
     * @param {UpdateBribeRequest} updateBribeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public updateAuctionOrderBribe(coinId: string, updateBribeRequest: UpdateBribeRequest, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).updateAuctionOrderBribe(coinId, updateBribeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionPublicControllerApi - axios parameter creator
 * @export
 */
export const TransactionPublicControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTransaction: async (createTransactionRequest: CreateTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionRequest' is not null or undefined
            assertParamExists('createOrderTransaction', 'createTransactionRequest', createTransactionRequest)
            const localVarPath = `/public/v1/coins/transactions/tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignData: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getSignData', 'code', code)
            const localVarPath = `/public/v1/coins/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransaction', 'transactionId', transactionId)
            const localVarPath = `/public/v1/coins/transactions/tx/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {SignTransactionRequest} signTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction: async (transactionId: string, signTransactionRequest: SignTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('signTransaction', 'transactionId', transactionId)
            // verify required parameter 'signTransactionRequest' is not null or undefined
            assertParamExists('signTransaction', 'signTransactionRequest', signTransactionRequest)
            const localVarPath = `/public/v1/coins/transactions/tx/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionPublicControllerApi - functional programming interface
 * @export
 */
export const TransactionPublicControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionPublicControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderTransaction(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderTransaction(createTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionPublicControllerApi.createOrderTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignData(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignData(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionPublicControllerApi.getSignData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionPublicControllerApi.getTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {SignTransactionRequest} signTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signTransaction(transactionId: string, signTransactionRequest: SignTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signTransaction(transactionId, signTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionPublicControllerApi.signTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionPublicControllerApi - factory interface
 * @export
 */
export const TransactionPublicControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionPublicControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderTransaction(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateTransactionResponse> {
            return localVarFp.createOrderTransaction(createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignData(code: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSignDataResponse> {
            return localVarFp.getSignData(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetTransactionResponse> {
            return localVarFp.getTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {SignTransactionRequest} signTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction(transactionId: string, signTransactionRequest: SignTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signTransaction(transactionId, signTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionPublicControllerApi - object-oriented interface
 * @export
 * @class TransactionPublicControllerApi
 * @extends {BaseAPI}
 */
export class TransactionPublicControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPublicControllerApi
     */
    public createOrderTransaction(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionPublicControllerApiFp(this.configuration).createOrderTransaction(createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPublicControllerApi
     */
    public getSignData(code: string, options?: RawAxiosRequestConfig) {
        return TransactionPublicControllerApiFp(this.configuration).getSignData(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPublicControllerApi
     */
    public getTransaction(transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionPublicControllerApiFp(this.configuration).getTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transactionId 
     * @param {SignTransactionRequest} signTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPublicControllerApi
     */
    public signTransaction(transactionId: string, signTransactionRequest: SignTransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionPublicControllerApiFp(this.configuration).signTransaction(transactionId, signTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('edit', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async me(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.me(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.me']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.edit(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.me(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public edit(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).edit(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public me(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).me(options).then((request) => request(this.axios, this.basePath));
    }
}



